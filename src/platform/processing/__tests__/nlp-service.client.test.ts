import { NLPServiceClient, NLPServiceError } from '../nlp-service.client';
import axios from 'axios';

// Mock axios
jest.mock('axios');
const mockedAxios = axios as jest.Mocked<typeof axios>;

describe('NLPServiceClient', () => {
  let client: NLPServiceClient;
  let mockAxiosInstance: any;

  beforeEach(() => {
    // Reset mocks
    jest.clearAllMocks();
    
    // Create mock axios instance
    mockAxiosInstance = {
      request: jest.fn(),
    };
    
    mockedAxios.create.mockReturnValue(mockAxiosInstance);
    
    client = new NLPServiceClient('http://localhost:8000');
  });

  describe('constructor', () => {
    it('should create axios instance with correct configuration', () => {
      expect(mockedAxios.create).toHaveBeenCalledWith({
        baseURL: 'http://localhost:8000',
        timeout: 300000,
        headers: {
          'Content-Type': 'application/json',
          'User-Agent': 'NLP-Service-Client/1.0'
        }
      });
    });

    it('should remove trailing slash from base URL', () => {
      new NLPServiceClient('http://localhost:8000/');
      expect(mockedAxios.create).toHaveBeenCalledWith(
        expect.objectContaining({
          baseURL: 'http://localhost:8000'
        })
      );
    });
  });

  describe('healthCheck', () => {
    it('should return health status', async () => {
      const mockResponse = {
        status: 'healthy',
        timestamp: '2024-01-01T12:00:00Z'
      };

      mockAxiosInstance.request.mockResolvedValue({
        data: mockResponse
      });

      const result = await client.healthCheck();

      expect(mockAxiosInstance.request).toHaveBeenCalledWith({
        method: 'GET',
        url: '/health',
        data: undefined
      });
      expect(result).toEqual(mockResponse);
    });

    it('should handle HTTP errors', async () => {
      const errorResponse = {
        response: {
          status: 500,
          data: { detail: 'Internal server error' }
        }
      };

      mockAxiosInstance.request.mockRejectedValue(errorResponse);

      await expect(client.healthCheck()).rejects.toThrow(NLPServiceError);
      await expect(client.healthCheck()).rejects.toThrow('HTTP 500: Internal server error');
    });
  });

  describe('getAvailableOntologies', () => {
    it('should return ontology information', async () => {
      const mockResponse = {
        available_ontologies: ['financial', 'procurement'],
        default_ontology: 'default',
        ontology_details: {
          financial: {
            entity_types: ['COMPANY_NAME', 'PERSON_NAME']
          }
        }
      };

      mockAxiosInstance.request.mockResolvedValue({
        data: mockResponse
      });

      const result = await client.getAvailableOntologies();

      expect(mockAxiosInstance.request).toHaveBeenCalledWith({
        method: 'GET',
        url: '/ontologies',
        data: undefined
      });
      expect(result).toEqual(mockResponse);
    });
  });

  describe('extractEntities', () => {
    it('should extract entities without ontology', async () => {
      const mockResponse = [
        {
          type: 'COMPANY_NAME',
          value: 'Apple Inc.',
          confidence: 0.85
        }
      ];

      mockAxiosInstance.request.mockResolvedValue({
        data: mockResponse
      });

      const result = await client.extractEntities('Apple Inc. CEO Tim Cook');

      expect(mockAxiosInstance.request).toHaveBeenCalledWith({
        method: 'POST',
        url: '/extract-entities',
        data: { text: 'Apple Inc. CEO Tim Cook' }
      });
      expect(result).toEqual(mockResponse);
    });

    it('should extract entities with ontology', async () => {
      const mockResponse = [
        {
          type: 'COMPANY_NAME',
          value: 'Apple Inc.',
          confidence: 0.85
        }
      ];

      mockAxiosInstance.request.mockResolvedValue({
        data: mockResponse
      });

      const result = await client.extractEntities('Apple Inc. CEO Tim Cook', 'financial');

      expect(mockAxiosInstance.request).toHaveBeenCalledWith({
        method: 'POST',
        url: '/extract-entities',
        data: { 
          text: 'Apple Inc. CEO Tim Cook',
          ontology_name: 'financial'
        }
      });
      expect(result).toEqual(mockResponse);
    });
  });

  describe('extractGraph', () => {
    it('should extract knowledge graph', async () => {
      const mockResponse = {
        entities: [
          {
            type: 'COMPANY_NAME',
            value: 'Apple Inc.',
            confidence: 0.9
          }
        ],
        relationships: [
          {
            source: 'Tim Cook',
            target: 'Apple Inc.',
            type: 'WORKS_FOR',
            confidence: 0.9
          }
        ],
        refinement_info: 'Graph generated by LLM',
        ontology_used: 'financial'
      };

      mockAxiosInstance.request.mockResolvedValue({
        data: mockResponse
      });

      const result = await client.extractGraph('Apple Inc. CEO Tim Cook', 'financial');

      expect(mockAxiosInstance.request).toHaveBeenCalledWith({
        method: 'POST',
        url: '/extract-graph',
        data: { 
          text: 'Apple Inc. CEO Tim Cook',
          ontology_name: 'financial'
        }
      });
      expect(result).toEqual(mockResponse);
    });
  });

  describe('batchExtractGraph', () => {
    it('should extract graphs from multiple texts', async () => {
      const mockResponse = [
        {
          entities: [{ type: 'COMPANY_NAME', value: 'Apple Inc.' }],
          relationships: [],
          refinement_info: 'Graph 1',
          ontology_used: 'financial'
        },
        {
          entities: [{ type: 'COMPANY_NAME', value: 'Microsoft Corp.' }],
          relationships: [],
          refinement_info: 'Graph 2',
          ontology_used: 'financial'
        }
      ];

      mockAxiosInstance.request.mockResolvedValue({
        data: mockResponse
      });

      const texts = ['Apple Inc. CEO Tim Cook', 'Microsoft Corp. CEO Satya Nadella'];
      const result = await client.batchExtractGraph(texts, 'financial');

      expect(mockAxiosInstance.request).toHaveBeenCalledWith({
        method: 'POST',
        url: '/batch-extract-graph',
        data: { 
          texts,
          ontology_name: 'financial'
        }
      });
      expect(result).toEqual(mockResponse);
    });
  });

  describe('generateEmbeddings', () => {
    it('should generate embeddings for texts', async () => {
      const mockResponse = {
        embeddings: [
          [0.1, 0.2, 0.3],
          [0.4, 0.5, 0.6]
        ]
      };

      mockAxiosInstance.request.mockResolvedValue({
        data: mockResponse
      });

      const texts = ['Apple Inc.', 'Microsoft Corp.'];
      const result = await client.generateEmbeddings(texts);

      expect(mockAxiosInstance.request).toHaveBeenCalledWith({
        method: 'POST',
        url: '/embed',
        data: { texts }
      });
      expect(result).toEqual(mockResponse.embeddings);
    });
  });

  describe('error handling', () => {
    it('should retry on network errors', async () => {
      const networkError = new Error('Network error');
      
      mockAxiosInstance.request
        .mockRejectedValueOnce(networkError)
        .mockRejectedValueOnce(networkError)
        .mockResolvedValue({
          data: { status: 'healthy' }
        });

      const result = await client.healthCheck();

      expect(mockAxiosInstance.request).toHaveBeenCalledTimes(3);
      expect(result).toEqual({ status: 'healthy' });
    });

    it('should throw error after max retries', async () => {
      const networkError = new Error('Network error');
      
      mockAxiosInstance.request.mockRejectedValue(networkError);

      await expect(client.healthCheck()).rejects.toThrow('Request failed after 3 retries: Network error');
      expect(mockAxiosInstance.request).toHaveBeenCalledTimes(4); // 1 initial + 3 retries
    });
  });
}); 