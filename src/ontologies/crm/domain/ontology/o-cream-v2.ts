import { v4 as uuidv4 } from 'uuid';
// This file is auto-generated by scripts/sync-ontology.ts. Do not edit manually.
// Based on DOLCE foundational ontology

export enum DOLCECategory {
  Abstract = 'Abstract',
  PhysicalObject = 'PhysicalObject',
  AmountOfMatter = 'AmountOfMatter',
  ArbitrarySum = 'ArbitrarySum',
  SocialObject = 'SocialObject',
  MentalObject = 'MentalObject',
  LinguisticObject = 'LinguisticObject',
  InformationObject = 'InformationObject',
  // CRMPLATFORM = 'CRMPlatform', // Obsolete
}

export enum RelationshipType {
  CUSTOMERRELATIONSHIP = 'CustomerRelationship',
  SUPPLIERRELATIONSHIP = 'SupplierRelationship',
  PARTNERRELATIONSHIP = 'PartnerRelationship',
  PROSPECTRELATIONSHIP = 'ProspectRelationship',
  EMPLOYMENT = 'Employment',
  COLLABORATION = 'Collaboration',
  MEMBERSHIP = 'Membership',
  BEFORE = 'Before',
  AFTER = 'After',
  DURING = 'During',
  OVERLAPS = 'Overlaps',
}

export enum KnowledgeType {
  CUSTOMERPROFILE = 'CustomerProfile',
  CUSTOMERPREFERENCES = 'CustomerPreferences',
  CUSTOMERBEHAVIOR = 'CustomerBehavior',
  CUSTOMERHISTORY = 'CustomerHistory',
  MARKETINTELLIGENCE = 'MarketIntelligence',
  COMPETITIVEANALYSIS = 'CompetitiveAnalysis',
  PRODUCTKNOWLEDGE = 'ProductKnowledge',
  PROCESSKNOWLEDGE = 'ProcessKnowledge',
  TRANSACTIONDATA = 'TransactionData',
  INTERACTIONHISTORY = 'InteractionHistory',
  COMMUNICATIONLOG = 'CommunicationLog',
}

export enum ActivityType {
  IDENTIFY = 'Identify',
  ATTRACT = 'Attract',
  ACQUIRE = 'Acquire',
  DEVELOP = 'Develop',
  RETAIN = 'Retain',
  LEADQUALIFICATION = 'LeadQualification',
  OPPORTUNITYMANAGEMENT = 'OpportunityManagement',
  PROPOSALPREPARATION = 'ProposalPreparation',
  NEGOTIATION = 'Negotiation',
  CLOSING = 'Closing',
  CAMPAIGNEXECUTION = 'CampaignExecution',
  CONTENTCREATION = 'ContentCreation',
  MARKETRESEARCH = 'MarketResearch',
  BRANDMANAGEMENT = 'BrandManagement',
  CUSTOMERSUPPORT = 'CustomerSupport',
  ISSUERESOLUTION = 'IssueResolution',
  MAINTENANCE = 'Maintenance',
  TRAINING = 'Training',
  DATACOLLECTION = 'DataCollection',
  DATAANALYSIS = 'DataAnalysis',
  REPORTING = 'Reporting',
  DOCUMENTMANAGEMENT = 'DocumentManagement',
  Other = 'Other',
}

export enum SoftwareType {
  SALESAUTOMATION = 'SalesAutomation',
  MARKETINGAUTOMATION = 'MarketingAutomation',
  EMAILSYSTEM = 'EmailSystem',
  KNOWLEDGEGRAPH = 'KnowledgeGraph',
  API = 'API',
}

export interface DOLCEEntity {
  id: string;
  category: DOLCECategory;
  createdAt: Date;
  updatedAt: Date;
}

export interface InformationElement extends DOLCEEntity {
  category: DOLCECategory.Abstract;
  type: KnowledgeType;
  title: string;
  content: any;
  format: 'text' | 'json' | 'xml' | 'binary' | 'multimedia';
  source: string;
  reliability: number;
  confidentiality: 'public' | 'internal' | 'confidential' | 'restricted';
  version: string;
  relatedEntities: string[];
  metadata: Record<string, any>;
  knowledgeType?: KnowledgeType | string;
}

export interface Activity extends DOLCEEntity {
  name: string;
  activityType: ActivityType | string;
  startTime?: Date;
  endTime?: Date;
  duration?: number;
  status: 'planned' | 'in_progress' | 'completed' | 'cancelled' | 'failed';
  success: boolean;
  cost?: number;
  outcome?: string;
  performanceMetrics?: Record<string, number>;
  location?: string;
  channel?: string;
  context: Record<string, any>;
  participants?: InformationElement[];
}

// Relationship definitions
export interface OCreamRelationship {
  id: string;
  relationshipType: string;
  sourceEntityId: string;
  targetEntityId: string;
  sourceRole?: string;
  targetRole?: string;
  temporal: {
    startTime?: Date;
    endTime?: Date;
    duration?: number;
  };
  properties: Record<string, any>;
  context?: string;
  strength?: number;
  createdAt: Date;
  updatedAt: Date;
}

// Software module
export interface SoftwareSystem extends DOLCEEntity {
  category: DOLCECategory.PhysicalObject;
  type: SoftwareType;
  name: string;
  version: string;
  vendor: string;
  capabilities: string[];
  status: 'active' | 'inactive' | 'maintenance' | 'deprecated';
  deployment: 'on-premise' | 'cloud' | 'hybrid';
}

// Core CRM Entities based on DOLCE
export interface Agent extends DOLCEEntity {
  category: DOLCECategory.PhysicalObject;
  name: string;
}

export interface Person extends Agent {
  firstName?: string;
  lastName?: string;
  email: string;
  phone?: string;
  title?: string; // e.g., 'Managing Director'
}

export interface Organization extends Agent {
  legalName: string;
  aliases?: string[];
  industry?: string;
  website?: string;
  metadata?: Record<string, any>; // For EDGAR, CIK, etc.
  name: string;
}

export type OCreamContactEntity = (Person | Organization) & {
  knowledgeElements?: string[];
  activities?: string[];
  ontologyMetadata?: {
    validationStatus: 'valid' | 'invalid' | 'partial';
  };
  getName(): string;
};

export class OCreamV2Ontology {
  private static instance: OCreamV2Ontology;
  private entities: Map<string, DOLCEEntity> = new Map();
  private relationships: Map<string, OCreamRelationship> = new Map();
  private typeIndex: Map<string, Set<string>> = new Map();
  private relationshipIndex: Map<string, Set<string>> = new Map();

  constructor() {
    // Initialize type indices
    Object.values(DOLCECategory).forEach(category => {
      this.typeIndex.set(category, new Set());
    });
  }

  public static getInstance(): OCreamV2Ontology {
    if (!OCreamV2Ontology.instance) {
      OCreamV2Ontology.instance = new OCreamV2Ontology();
    }
    return OCreamV2Ontology.instance;
  }

  public getStatistics() {
    return {
      entityCount: this.entities.size,
      relationshipCount: this.relationships.size,
      knowledgeElementCount: this.getEntitiesByType(DOLCECategory.Abstract).length,
      activityCount: this.getEntitiesByType(DOLCECategory.PhysicalObject).length,
      typeDistribution: Object.fromEntries(
        Array.from(this.typeIndex.entries()).map(([type, ids]) => [type, ids.size])
      )
    };
  }

  addEntity(entity: DOLCEEntity): void {
    if (this.entities.has(entity.id)) {
      throw new Error(`Entity with id ${entity.id} already exists.`);
    }
    this.entities.set(entity.id, entity);
    
    // Update type index
    if (!this.typeIndex.has(entity.category)) {
      this.typeIndex.set(entity.category, new Set());
    }
    this.typeIndex.get(entity.category)!.add(entity.id);
  }

  getEntity(id: string): DOLCEEntity | undefined {
    return this.entities.get(id);
  }

  getEntitiesByType(category: DOLCECategory): DOLCEEntity[] {
    const ids = this.typeIndex.get(category) || new Set();
    return Array.from(ids).map(id => this.entities.get(id)!).filter(Boolean);
  }

  updateEntity(id: string, updates: Partial<DOLCEEntity>): DOLCEEntity | undefined {
    const entity = this.entities.get(id);
    if (!entity) {
      return undefined;
    }

    const oldCategory = entity.category;
    const updatedEntity = { ...entity, ...updates, updatedAt: new Date() };

    if (updates.category && updates.category !== oldCategory) {
      this.typeIndex.get(oldCategory)?.delete(id);
      if (!this.typeIndex.has(updates.category)) {
        this.typeIndex.set(updates.category, new Set());
      }
      this.typeIndex.get(updates.category)!.add(id);
    }

    this.entities.set(id, updatedEntity);
    return updatedEntity;
  }

  addRelationship(relationship: OCreamRelationship): void {
    this.relationships.set(relationship.id, relationship);
    
    // Update relationship index
    const sourceKey = relationship.sourceEntityId;
    const targetKey = relationship.targetEntityId;
    
    if (!this.relationshipIndex.has(sourceKey)) {
      this.relationshipIndex.set(sourceKey, new Set());
    }
    if (!this.relationshipIndex.has(targetKey)) {
      this.relationshipIndex.set(targetKey, new Set());
    }
    
    this.relationshipIndex.get(sourceKey)!.add(relationship.id);
    this.relationshipIndex.get(targetKey)!.add(relationship.id);
  }

  getRelationshipsForEntity(entityId: string): OCreamRelationship[] {
    const relationshipIds = this.relationshipIndex.get(entityId) || new Set();
    return Array.from(relationshipIds)
      .map(id => this.relationships.get(id)!)
      .filter(Boolean);
  }

  findRelatedEntities(entityId: string, relationshipType?: string): DOLCEEntity[] {
    const relationships = this.getRelationshipsForEntity(entityId);
    const filteredRels = relationshipType 
      ? relationships.filter(r => r.relationshipType === relationshipType)
      : relationships;

    const relatedIds = new Set<string>();
    filteredRels.forEach(rel => {
      if (rel.sourceEntityId !== entityId) {
        relatedIds.add(rel.sourceEntityId);
      }
      if (rel.targetEntityId !== entityId) {
        relatedIds.add(rel.targetEntityId);
      }
    });

    return Array.from(relatedIds)
      .map(id => this.entities.get(id)!)
      .filter(Boolean);
  }

  validateEntity(entity: DOLCEEntity): boolean {
    // Validate DOLCE category constraints
    switch (entity.category) {
      case DOLCECategory.PhysicalObject:
        return this.validatePhysicalObject(entity);
      case DOLCECategory.Abstract:
        return this.validateAbstract(entity);
      default:
        return false;
    }
  }

  private validatePhysicalObject(entity: DOLCEEntity): boolean {
    // Physical objects persist through time
    return entity.createdAt <= entity.updatedAt;
  }

  private validateAbstract(entity: DOLCEEntity): boolean {
    // Abstract entities have no spatial or temporal qualities
    return entity.createdAt <= entity.updatedAt;
  }

  exportOntology(): any {
    return {
      metadata: {
        name: 'O-CREAM-v2',
        version: '2.0',
        foundation: 'DOLCE',
        modules: ['Relationships', 'Knowledge', 'Activities', 'Software', 'Miscellaneous'],
        createdAt: new Date(),
        entityCount: this.entities.size,
        relationshipCount: this.relationships.size
      },
      entities: Array.from(this.entities.values()),
      relationships: Array.from(this.relationships.values()),
      typeDistribution: Object.fromEntries(
        Array.from(this.typeIndex.entries()).map(([type, ids]) => [type, ids.size])
      )
    };
  }

  addKnowledgeElement(id: string, type: string, knowledgeElement: InformationElement): void {
    // Add knowledge element as an abstract entity
    this.addEntity(knowledgeElement);
  }

  addActivity(id: string, type: string, activity: Activity): void {
    const fullId = `${type}:${id}`;
    if (this.entities.has(fullId)) {
      throw new Error(`Activity with id ${fullId} already exists.`);
    }
    this.entities.set(fullId, { ...activity, id: fullId, category: DOLCECategory.PhysicalObject });
  }

  removeEntity(id: string): void {
    const entity = this.entities.get(id);
    if (!entity) return;

    // Remove from main entity map
    this.entities.delete(id);

    // Remove from type index
    if (this.typeIndex.has(entity.category)) {
      this.typeIndex.get(entity.category)!.delete(id);
    }

    // In a real implementation, you'd also need to handle cascading deletes for relationships
  }
}

export const oCreamV2 = new OCreamV2Ontology();

// Factory function for creating information elements
export function createInformationElement(data: Partial<InformationElement>): InformationElement {
  const now = new Date();
  return {
    id: data.id || uuidv4(),
    category: DOLCECategory.Abstract,
    type: data.type || KnowledgeType.COMMUNICATIONLOG,
    title: data.title || 'Untitled Information Element',
    content: data.content || null,
    format: data.format || 'json',
    source: data.source || 'Unknown',
    reliability: data.reliability ?? 0.5,
    confidentiality: data.confidentiality || 'internal',
    version: data.version || '1.0',
    relatedEntities: data.relatedEntities || [],
    metadata: data.metadata || {},
    createdAt: now,
    updatedAt: now,
    knowledgeType: data.knowledgeType,
    ...data,
  };
}

export function createActivity(data: Partial<Activity>): Activity {
  const now = new Date();
  return {
    id: data.id || `activity-${Date.now()}`,
    name: data.name || 'Activity',
    category: DOLCECategory.SocialObject,
    activityType: data.activityType || ActivityType.Other,
    status: data.status || 'planned',
    success: data.success ?? false,
    context: data.context || {},
    participants: data.participants || [],
    createdAt: now,
    updatedAt: now,
    ...data,
  };
}

export function isPerson(entity: DOLCEEntity): entity is Person {
  return entity.category === DOLCECategory.PhysicalObject && 'email' in entity;
}

export function isOrganization(entity: DOLCEEntity): entity is Organization {
  return entity.category === DOLCECategory.SocialObject && 'name' in entity;
}

export function isActivity(entity: DOLCEEntity): entity is Activity {
  const activity = entity as Activity;
  return activity.activityType !== undefined;
}
