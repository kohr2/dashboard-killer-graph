// O-CREAM-v2 Compliant Contact Entity
// This creates O-CREAM-v2 ontological structure for contacts

import { 
  DOLCECategory, 
  DOLCEEntity,
  InformationElement,
  KnowledgeType,
  createInformationElement,
  oCreamV2
} from '../ontology/o-cream-v2';

// Simple UUID generator
function generateUUID(): string {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
    const r = Math.random() * 16 | 0;
    const v = c === 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
}

// O-CREAM-v2 Contact Entity
export class OCreamContactEntity implements DOLCEEntity {
  public readonly id: string;
  public readonly category: DOLCECategory.AGENTIVE_PHYSICAL_OBJECT = DOLCECategory.AGENTIVE_PHYSICAL_OBJECT;
  public readonly createdAt: Date;
  public updatedAt: Date;

  // Contact-specific properties
  public personalInfo: {
    firstName: string;
    lastName: string;
    title?: string;
    email: string;
    phone?: string;
    address?: any;
  };
  
  public organizationId?: string;
  public role?: string;
  public relationships: string[] = [];
  public activities: string[] = [];
  public preferences: Record<string, any> = {};
  public communicationHistory: string[] = [];
  public knowledgeElements: string[] = [];
  public status: 'active' | 'inactive' | 'blocked' = 'active';
  
  public ontologyMetadata: {
    lastOntologyUpdate: Date;
    ontologyVersion: string;
    validationStatus: 'valid' | 'invalid' | 'pending';
    validationErrors?: string[];
  };

  constructor(data: {
    firstName: string;
    lastName: string;
    email: string;
    phone?: string;
    organizationId?: string;
    title?: string;
    address?: any;
    preferences?: Record<string, any>;
  }) {
    this.id = generateUUID();
    this.createdAt = new Date();
    this.updatedAt = new Date();

    // Set personal info
    this.personalInfo = {
      firstName: data.firstName,
      lastName: data.lastName,
      title: data.title,
      email: data.email,
      phone: data.phone,
      address: data.address
    };

    this.organizationId = data.organizationId;
    this.preferences = data.preferences || {};

    // Initialize ontology metadata
    this.ontologyMetadata = {
      lastOntologyUpdate: new Date(),
      ontologyVersion: '2.0',
      validationStatus: 'pending',
      validationErrors: []
    };

    // Register with global ontology
    this.registerWithOntology();

    // Create initial knowledge elements
    this.createInitialKnowledgeElements();

    // Validate against ontology
    this.validateOntology();
  }

  // Ontology Management Methods
  private registerWithOntology(): void {
    oCreamV2.addEntity(this);
  }

  private createInitialKnowledgeElements(): void {
    // Create customer profile knowledge element
    const profileKnowledge = createInformationElement({
      title: `Contact Profile: ${this.personalInfo.firstName} ${this.personalInfo.lastName}`,
      type: KnowledgeType.CUSTOMER_PROFILE,
      content: {
        personalInfo: this.personalInfo,
        preferences: this.preferences,
        status: this.status,
        createdAt: this.createdAt,
        lastUpdate: this.updatedAt
      },
      source: 'CRM System',
      reliability: 1.0,
      confidentiality: 'internal',
      relatedEntities: [this.id],
      metadata: {
        entityType: 'Contact',
        entityId: this.id,
        autoGenerated: true
      }
    });

    this.knowledgeElements.push(profileKnowledge.id);
    oCreamV2.addEntity(profileKnowledge);

    // Create customer preferences knowledge element if preferences exist
    if (Object.keys(this.preferences).length > 0) {
      const preferencesKnowledge = createInformationElement({
        title: `Contact Preferences: ${this.personalInfo.firstName} ${this.personalInfo.lastName}`,
        type: KnowledgeType.CUSTOMER_PREFERENCES,
        content: this.preferences,
        source: 'CRM System',
        reliability: 0.9,
        confidentiality: 'internal',
        relatedEntities: [this.id],
        metadata: {
          entityType: 'Contact',
          entityId: this.id,
          preferenceCount: Object.keys(this.preferences).length
        }
      });

      this.knowledgeElements.push(preferencesKnowledge.id);
      oCreamV2.addEntity(preferencesKnowledge);
    }
  }

  public validateOntology(): boolean {
    const isValid = oCreamV2.validateEntity(this);
    
    this.ontologyMetadata.validationStatus = isValid ? 'valid' : 'invalid';
    this.ontologyMetadata.lastOntologyUpdate = new Date();
    
    if (!isValid) {
      this.ontologyMetadata.validationErrors = [
        'Entity failed DOLCE category validation'
      ];
    } else {
      this.ontologyMetadata.validationErrors = [];
    }

    return isValid;
  }

  // Relationship Management
  public addRelationship(relationshipId: string): void {
    if (!this.relationships.includes(relationshipId)) {
      this.relationships.push(relationshipId);
      this.updateOntologyMetadata();
    }
  }

  public removeRelationship(relationshipId: string): void {
    const index = this.relationships.indexOf(relationshipId);
    if (index > -1) {
      this.relationships.splice(index, 1);
      this.updateOntologyMetadata();
    }
  }

  // Activity Management
  public addActivity(activityId: string): void {
    if (!this.activities.includes(activityId)) {
      this.activities.push(activityId);
      this.updateOntologyMetadata();
    }
  }

  public addCommunicationActivity(activityId: string): void {
    this.addActivity(activityId);
    if (!this.communicationHistory.includes(activityId)) {
      this.communicationHistory.push(activityId);
    }
  }

  // Knowledge Management
  public addKnowledgeElement(knowledgeId: string): void {
    if (!this.knowledgeElements.includes(knowledgeId)) {
      this.knowledgeElements.push(knowledgeId);
      this.updateOntologyMetadata();
    }
  }

  public getKnowledgeElements(): InformationElement[] {
    return this.knowledgeElements
      .map(id => oCreamV2.getEntity(id))
      .filter(entity => entity && entity.category === DOLCECategory.ABSTRACT)
      .map(entity => entity as InformationElement);
  }

  // Preference Management
  public updatePreferences(preferences: Record<string, any>): void {
    this.preferences = { ...this.preferences, ...preferences };
    this.updateKnowledgeElements();
    this.updateOntologyMetadata();
  }

  public getPreference(key: string): any {
    return this.preferences[key];
  }

  public setPreference(key: string, value: any): void {
    this.preferences[key] = value;
    this.updateKnowledgeElements();
    this.updateOntologyMetadata();
  }

  // Status Management
  public updateStatus(status: 'active' | 'inactive' | 'blocked'): void {
    this.status = status;
    this.updateKnowledgeElements();
    this.updateOntologyMetadata();
  }

  // Contact Info Management
  public updatePersonalInfo(info: Partial<typeof this.personalInfo>): void {
    this.personalInfo = { ...this.personalInfo, ...info };
    this.updatedAt = new Date();
    this.updateKnowledgeElements();
    this.updateOntologyMetadata();
  }

  // Private helper methods
  private updateOntologyMetadata(): void {
    this.updatedAt = new Date();
    this.ontologyMetadata.lastOntologyUpdate = new Date();
    this.validateOntology();
  }

  private updateKnowledgeElements(): void {
    // Update existing knowledge elements with current data
    const profileKnowledge = this.getKnowledgeElements()
      .find(ke => ke.type === KnowledgeType.CUSTOMER_PROFILE);
    
    if (profileKnowledge) {
      profileKnowledge.content = {
        personalInfo: this.personalInfo,
        preferences: this.preferences,
        status: this.status,
        createdAt: this.createdAt,
        lastUpdate: new Date()
      };
      profileKnowledge.updatedAt = new Date();
    }

    // Update preferences knowledge element
    const preferencesKnowledge = this.getKnowledgeElements()
      .find(ke => ke.type === KnowledgeType.CUSTOMER_PREFERENCES);
    
    if (preferencesKnowledge) {
      preferencesKnowledge.content = this.preferences;
      preferencesKnowledge.updatedAt = new Date();
      preferencesKnowledge.metadata.preferenceCount = Object.keys(this.preferences).length;
    }
  }

  // O-CREAM-v2 Export
  public exportOntologyData(): any {
    return {
      entity: {
        id: this.id,
        category: this.category,
        personalInfo: this.personalInfo,
        relationships: this.relationships,
        activities: this.activities,
        preferences: this.preferences,
        communicationHistory: this.communicationHistory,
        knowledgeElements: this.knowledgeElements,
        status: this.status,
        createdAt: this.createdAt,
        updatedAt: this.updatedAt
      },
      ontologyMetadata: this.ontologyMetadata,
      knowledgeElements: this.getKnowledgeElements(),
      validation: {
        isValid: this.ontologyMetadata.validationStatus === 'valid',
        errors: this.ontologyMetadata.validationErrors
      }
    };
  }

  // JSON export with ontology data
  public toJSON(): any {
    return {
      id: this.id,
      category: this.category,
      personalInfo: this.personalInfo,
      organizationId: this.organizationId,
      role: this.role,
      relationships: this.relationships,
      activities: this.activities,
      preferences: this.preferences,
      communicationHistory: this.communicationHistory,
      knowledgeElements: this.knowledgeElements,
      status: this.status,
      ontologyMetadata: this.ontologyMetadata,
      createdAt: this.createdAt,
      updatedAt: this.updatedAt
    };
  }
}

// Factory function for creating O-CREAM-v2 compliant contacts
export function createOCreamContact(data: {
  firstName: string;
  lastName: string;
  email: string;
  phone?: string;
  organizationId?: string;
  title?: string;
  address?: any;
  preferences?: Record<string, any>;
}): OCreamContactEntity {
  return new OCreamContactEntity(data);
} 