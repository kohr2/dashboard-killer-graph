import { EmailFixtureGenerationService } from '../email-fixture-generation.service';
import { promises as fs } from 'fs';
import path from 'path';

// Mock fs module
jest.mock('fs', () => ({
  promises: {
    readFile: jest.fn(),
    mkdir: jest.fn().mockResolvedValue(undefined),
    writeFile: jest.fn().mockResolvedValue(undefined),
    readdir: jest.fn().mockResolvedValue([]), // Mock readdir to return empty array
  },
}));

// Mock OpenAI
jest.mock('openai', () => ({
  default: jest.fn().mockImplementation(() => ({
    chat: {
      completions: {
        create: jest.fn().mockResolvedValue({
          choices: [{
            message: {
              content: 'Mock email content generated by OpenAI'
            }
          }]
        })
      }
    }
  }))
}));

describe('EmailFixtureGenerationService', () => {
  let service: EmailFixtureGenerationService;
  let mockFs: jest.Mocked<typeof fs>;

  beforeEach(() => {
    // Reset all mocks
    jest.clearAllMocks();

    mockFs = fs as jest.Mocked<typeof fs>;
    service = new EmailFixtureGenerationService();
  });

  describe('generateSingleEmailFixture', () => {
    it('should generate an email fixture with ontology-agnostic content', async () => {
      // Mock ontology data
      const mockOntology = {
        name: 'procurement',
        source: {
          url: 'https://example.com/ontology',
          type: 'owl',
          version: '1.0',
          description: 'Procurement ontology'
        },
        entities: [
          { name: 'Buyer', description: { _: 'A role of an agent that awards contracts' } },
          { name: 'Tenderer', description: { _: 'A role of an agent that submits tenders' } },
          { name: 'Mediator', description: { _: 'A role of an agent that resolves disputes' } },
          { name: 'Reviewer', description: { _: 'A role of an agent that investigates procedures' } },
          { name: 'TenderProcessor', description: { _: 'A role of an agent that processes tenders' } },
          { name: 'PaymentExecutor', description: { _: 'A role of an agent that executes payments' } },
          { name: 'ParticipationRequestProcessor', description: { _: 'A role of an agent that processes participation requests' } },
          { name: 'FrameworkAgreement', description: { _: 'An agreement between contracting authorities and economic operators' } },
          { name: 'LotGroup', description: { _: 'Combination of several lots for comparative assessment' } },
          { name: 'DesignContest', description: { _: 'A contest for design proposals' } },
          { name: 'ReviewProcedure', description: { _: 'Procedure for reviewing procurement decisions' } },
          { name: 'ParticipationRequestTerm', description: { _: 'Terms for requesting participation' } },
          { name: 'SubmissionTerm', description: { _: 'Terms for submitting documents' } },
        ],
        relationships: [
          { name: 'definesMediator', source: 'ProcedureTerm', target: 'Mediator', description: { _: 'Defines mediator' } },
          { name: 'definesReviewer', source: 'ReviewTerm', target: 'Reviewer', description: { _: 'Defines reviewer' } },
          { name: 'definesTenderProcessor', source: 'SubmissionTerm', target: 'TenderProcessor', description: { _: 'Defines tender processor' } },
          { name: 'definesPaymentExecutor', source: 'ContractTerm', target: 'PaymentExecutor', description: { _: 'Defines payment executor' } },
          { name: 'definesParticipationRequestProcessor', source: 'ParticipationRequestTerm', target: 'ParticipationRequestProcessor', description: { _: 'Defines participation request processor' } },
        ]
      };

      const mockConfig = {
        name: 'procurement',
        source: {
          url: 'https://example.com/ontology',
          type: 'owl',
          version: '1.0',
          description: 'Procurement ontology'
        },
        emailGeneration: {
          systemPrompt: 'You are a procurement expert. Generate professional emails.',
          promptTemplate: 'Generate a procurement email that naturally references {entities} and {context}.',
          currencies: ['EUR', 'USD'],
          locations: ['Brussels', 'Paris', 'Berlin'],
          statuses: ['Draft', 'Pending', 'Approved'],
          emailTypes: ['Request for Proposal', 'Contract Award', 'Clarification'],
          categories: ['Infrastructure', 'Technology', 'Services'],
          vendors: ['TechCorp', 'BuildCo', 'ServicePro']
        }
      };

      // Setup mocks
      mockFs.readFile
        .mockResolvedValueOnce(JSON.stringify(mockOntology)) // First call for ontology
        .mockResolvedValueOnce(JSON.stringify(mockConfig)); // Second call for config

      // Generate email fixture
      const result = await service.generateSingleEmailFixture('procurement');

      // Verify the result is a file path
      expect(typeof result).toBe('string');
      expect(result).toContain('.eml');

      // Verify fs.readFile was called for both ontology and config
      expect(mockFs.readFile).toHaveBeenCalledTimes(2);
    });

    it('should handle missing ontology gracefully', async () => {
      // Mock fs.readFile to throw error
      mockFs.readFile.mockRejectedValue(new Error('File not found'));

      await expect(service.generateSingleEmailFixture('nonexistent')).rejects.toThrow('File not found');
    });
  });

  describe('generateEmailFixtures', () => {
    it('should generate multiple email fixtures', async () => {
      const mockOntology = {
        name: 'procurement',
        source: {
          url: 'https://example.com/ontology',
          type: 'owl',
          version: '1.0',
          description: 'Procurement ontology'
        },
        entities: [
          { name: 'Buyer', description: { _: 'A role of an agent that awards contracts' } },
          { name: 'Tenderer', description: { _: 'A role of an agent that submits tenders' } },
        ],
        relationships: []
      };

      const mockConfig = {
        name: 'procurement',
        source: {
          url: 'https://example.com/ontology',
          type: 'owl',
          version: '1.0',
          description: 'Procurement ontology'
        },
        emailGeneration: {
          systemPrompt: 'You are a procurement expert.',
          promptTemplate: 'Generate a procurement email.',
          currencies: ['EUR'],
          locations: ['Brussels'],
          statuses: ['Draft'],
          emailTypes: ['Request for Proposal'],
          categories: ['Infrastructure'],
          vendors: ['TechCorp']
        }
      };

      // Setup mocks
      mockFs.readFile
        .mockResolvedValueOnce(JSON.stringify(mockOntology))
        .mockResolvedValueOnce(JSON.stringify(mockConfig));

      const options = {
        ontologyName: 'procurement',
        count: 3
      };

      const results = await service.generateEmailFixtures(options);

      expect(Array.isArray(results)).toBe(true);
      expect(results.length).toBeGreaterThan(0);
      results.forEach(filePath => {
        expect(typeof filePath).toBe('string');
        expect(filePath).toContain('.eml');
      });
    });
  });
}); 